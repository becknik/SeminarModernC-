% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
%\renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{mmap}
\usepackage[nomath]{lmodern}
\usepackage[T1,EU1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage[style=german]{csquotes}
\usepackage[skip=0pt,position=top,font=footnotesize,labelfont=bf,labelsep=endash]{caption}
\usepackage[htt]{hyphenat}

\usepackage{hyperref}
\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{arrows.meta,positioning,decorations.pathreplacing}
\usepackage{pgfplots}
%\pgfplotsset{compat=1.18}

\usepackage[backend=biber]{biblatex}
\addbibresource{cites.bib}

\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{enumerate}
\usepackage{float}
\usepackage{xcolor}
%% Listings setup:
\definecolor{keywords}{HTML}{000080}
\definecolor{types}{HTML}{000000}
\definecolor{instances}{HTML}{660E7A}
\definecolor{string}{rgb}{0.6,0,0}
\definecolor{comments}{HTML}{606060}
\lstset{
	% Formatting
	basicstyle={\ttfamily\scriptsize},
	% Syntax Highlighting:
	keywordstyle={\color{keywords}},
	otherkeywords={
		constexpr
		var
	},
	keywordstyle=[2]{\itshape\color{types}},
	%keywords=[2]{ fib },
	identifierstyle={\bfseries\color{instances}},
	stringstyle={\color{string}},
	commentstyle={\color{comments}},
	morecomment=[l]{*},
	% Code Lines formatting:
	numbers=left,
	numberstyle={\scriptsize\color{comments}},
	stepnumber=1,
	xleftmargin=20pt,
	% Misc:
	tabsize=4,
	showspaces=false,
	showstringspaces=false
}

\begin{document}
\title{Iteratoren, die Ranges-Bibliothek \& Views in C++23}
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
\author{Jannik Becker}
\authorrunning{J. Becker}
\institute{}
\maketitle
\vspace{-.5cm}
\begin{abstract}
	% 	Eine Aufarbeitung der Zugriffsmöglichkeiten auf C++-Container auf Stand des C++23-Standard.
	% 	Ausführlichen Diskussion der drei Iteratortypen nach  anhand der objektorientierten Iteratoren, Ranges-Bibliothek und Views.
	% 	Diskussion von Best-Practices und Einordnung der Konzepte durch ein Code-Benchmark nach .

	% Die Ausarbeitung konzentriert sich auf die Zugriffsmethoden auf C++-Container gemäß dem C++23-Standard, insbesondere auf die Einführung der Ranges-Bibliothek und Views.
	% Es wird diskutiert, wie diese Konzepte durch verschiedene Iterator-Kategorien nach \cite{plp} unterstützt werden, und ein Vergleich ihrer Leistungsfähigkeit durch einen Code-Benchmark wird vorgenommen.
	% Die Arbeit stellt die Entwicklung von einfachen Speicherzugriffsmethoden bis hin zu modernen Abstraktionen wie Ranges und Views dar und bewertet diese hinsichtlich Abstraktion, Lesbarkeit und Performanz.
	% Der Fokus liegt darauf, wie Ranges und Views das Programmieren in C++ vereinfachen und effizienter gestalten können.

	Diese Ausarbeitung untersucht moderne Zugriffsmethoden auf C++-Container auf Stand des C++23-Standards und widmet sich insbesondere der Ranges-Bibliothek und Views.
	Sie diskutiert die Funktionsweise von Iteratoren, Ranges und Views anhand der drei Iterator-Typen nach \cite{plp} und zeigt Best-Practices in der Verwendung dieser Konzepte auf.
	Schließlich werden Views und Iteratoren mittels eines komplexeren Beispiels hinsichtlich Abstraktion, Lesbarkeit und Performance verglichen.
	Dazu wird sich ein Benchmark unterschiedlicher Compiler zunutze gemacht.
	Dabei werden die Vor- und Nachteile von Ranges und Views im Kontext der C++-Programmierung beleuchtet.
	\keywords{ C++23\and Data Access\and Ranges\and Views}
\end{abstract}

\section{Einleitung}

In einem Informatik-Studium beschäftigt man sich in vielen Lehrveranstaltungen mit Algorithmen.
Dabei existieren viele Definitionen, was einen Algorithmus eigentlich auszeichnet.
Nach \cite[S.4]{aud} ist ein Algorithmus bspw. \enquote{[\dots] eine eindeutige Beschreibung eines in mehreren Schritten ausgeführten \mbox{(Bearbeitungs-)} [Vorgangs]}.

Neben dieser eindeutigen Beschreibung spielen beim Programmieren von Algorithmen allerdings auch die verwendeten Datenstrukturen und der Zugriff auf diese eine bedeutende Rolle.
Durch diese beiden Aspekte werden dem Programmierenden ein angemessenes Abstraktionsniveau ermöglicht \cite{aud}.
Deshalb macht es Sinn, sich neben Algorithmen und den einhergehenden Datenstrukturen auch mit den Zugriffsmöglichkeiten auf die inhärenten Daten auseinanderzusetzen.

Nun wurde mit der Einführung von \textit{Views} und der \textit{Ranges-Bibliothek} im C++20-Standard eine bahnbrechende Neuerung in die Standard Bibliothek eingegliedert.
Die beiden Konzepte ermöglichen eine funktionale und damit abstraktere Methode, um auf Informationen zuzugreifen und sie zu speichern.
Da sie daher das Potential haben, der Realisierung von Algorithmen und dem allgemeinen Programmieren in C++ zugute zu kommen, lohnt sich hier eine nähere Betrachtung und Bewertung.
Dies soll der Inhalt dieser Ausarbeitung sein.

Hierbei sollen zunächst typische Speicherzugriffsmöglichkeiten im C++-Standard vor C++20 aufgearbeitet werden.
Daraufhin soll ein tieferer Einblick in die C++20 Ranges-Bibliothek und Views geboten werden.
Die Diskussion aller Konzepte soll sich dabei an den drei grundlegenden Typen von Iteratoren nach Michael L. Scott orientieren \cite{plp}.
Schließlich sollen Views und Ranges anhand eines Codebeispiels nach den Kriterien der \textit{Abstraktion}, \textit{Lesbarkeit} und \textit{Performanz} mit C++-Iteratoren verglichen werden, wozu ein Benchmark des Beispiels zurate gezogen wird.

\section{Methodik}

Um verschiedene Speicherzugriffsarten vergleichbar darstellen zu können, sollen die folgenden Beispiele jeweils über das Array \texttt{fib} iterieren.
Dieses soll, von 0 beginnend, die ersten 11 Fibonacci-Zahlen beinhalten.

% \begin{figure}
% 	%\captionsetup{singlelinecheck=false} % justification=raggedright
% 	\caption{Code-Ramen für folgende Beispiele - Header: \texttt{array}, \texttt{iostream} (, \texttt{cstdint})}
% 	\label{code:frame}
% 	\begin{lstlisting}[language=C++]
% constexpr std::array<u_int32_t, 11> fib = { 0,1,1,2,3,5,8,13,21,34,55 };
% auto main() -> int {
% 	// Inline pieces of code from following examples right here
% 	return 0;
% }\end{lstlisting}
% \end{figure}

Der Code-Stil der Beispiele versucht sich an modernen C++ Best-Practices zu orientieren, wie sie bspw. in \cite{profcpp} beschrieben werden.
Um den Verzicht auf explizite Namensräume zu verdeutlichen, wird kein Namensraum vor dem \textit{Bereichsauflösungsoperator} \texttt{::} verwendet.

Von der im C++23-Standard eingeführten \texttt{print$($ln$)$}-Funktion zur vereinfachten Ausgabe von formatierten Strings nach \texttt{stdout} wurde zum Zeitpunk des Schreibens aus Verfügbarkeitsgründen verzichtet.

Nun wollen wir beginnen, die Zugriffswege auf C++-Container zu ergründen.

\subsection{Direkter Speicherzugriff}

Die von C übernommene Art auf die Elemente eines Containers zuzugreifen ist die Verwendung des \textit{Subscript-Operators} \texttt{operator[]} auf Pointer. % TODO
Dabei handelt es sich um eine direkte, speichergebundene Indexierung einer sequenziellen Datenstruktur (siehe \autoref{code:subscript-operator}).

\begin{figure}[H]
	\vspace{-1em}
	\centering
	\caption{Code-Beispiel: Iteration über \texttt{fib} mittels \texttt{operator[]}}
	\label{code:subscript-operator}
	\begin{lstlisting}[language=C++]
	for(auto i = 0; i < size(::fib); ++i) {
		std::cout << ::fib[i] << std::endl;
	}\end{lstlisting}
	\vspace{-1.5em}
\end{figure}

\noindent Diese Methode ist syntaktisch wenig abstrakt und fehleranfällig (vgl. \cite[S.274]{plp}).
Außerdem macht sie nur für sequenzielle Datenstrukturen Sinn, da sonst freistehende Hilfsprozeduren oder ein ähnliches Interface zu den C++ Iteratoren implementiert werden müssten.
Bevor näher auf letztere eingegangen werden soll, wollen wir vorerst generelle Iteratoren und die Kategorien, in die man sie aufgliedern kann, einführen.

\subsection{Iteratoren}

Iteratoren stellen in vielen abstrakten Programmiersprachen wie Java oder Python eine gängige Methode dar, um auf die Elemente beliebiger Container zuzugreifen.
Fundamental lassen sich Iteratoren nach \cite[S.269ff.]{plp} in die folgenden drei Kategorien einteilen:

\begin{enumerate}[1.]
	\label{enum:iterator-types}
	\item \textbf{Iterator Objects}: Gewöhnliche Objekte, die Methoden zur Initialisierung, Generierung des nächsten Elements und Test auf das Ende der Sequenz anbieten.
	      Der Fortschritt des Iterators wird hierbei in den Objektattributen der Iterator-Instanz gespeichert.

	\item \textbf{First-Class Iterators}: Der Code, welcher auf den Elementen des Containers ausgeführt werden soll, wird als Funktion verfasst.
	      Diese erhält ein Elemente des Containers als Argument.
	      Anschließend wird sie als Argument an den Iterator übergeben, der sie auf den Elementen des Containers aufruft.

	\item \textbf{True Iterators}: Beim Aufrufen einer True-Iterator-Funktion berechnet diese den nächsten Wert und gibt ihn durch ein spezielles Schlüsselwort an den Aufrufer zurück.
	      Dadurch wird der \textit{Problem Counter} und der innere Zustand der Funktion zwischengespeichert, sodass die Iterator-Prozedur bei erneuten Aufrufen hinter der letzten, speziellen Rückgabestelle fortgeführt werden kann.
	      Die Iteration endet, wenn die True-Iterator-Prozedur normal zum Aufrufer zurückkehrt.
\end{enumerate}

\noindent Jede Iterator-Variante ist in einem anderen Programmierparadigma typisch, jedoch sollen sie alle im Laufe dieser Ausarbeitung in einer Form in C++ auftauchen.
Beginnen wollen wir mit der bekanntesten in C++ enthaltenen Form.

\subsubsection{Iterator Objects}
\label{text:iterator-objects}

Iterator-Objekte stellen in C++ die Norm für das Iterieren über Container dar.
Aufgrund der Hardwarenähe der Sprache entsprechen sie hier einer Abstraktion über Pointer, anstatt Iteratoren in typischen OOP-Sprachen wie Java.
Um den Unterschied zu verdeutlichen, folgen zwei Beispiele mit Iterator Objects in Java (siehe \autoref{code:iterator-java}) und C++ (siehe \autoref{code:iterator-cpp}).

\begin{figure}
	\vspace{-1em}
	\caption{Iteration über \texttt{fib}-Liste mit Java-Iterator (JDK 21, \texttt{--enable-preview})}
	\label{code:iterator-java}
	\begin{lstlisting}[language=Java]
final List<Integer> fib = List.of(0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55);
void main() {
    for (var it = fib.iterator(); it.hasNext(); ) {
        System.out.println(it.next());
    }
}\end{lstlisting}
	\caption{Iteration über \texttt{fib} mittels C++ Iteratoren}
	\label{code:iterator-cpp}
	\begin{lstlisting}[language=C++]
	for (auto it = cbegin(::fib); it != cend(::fib); ++it) {
		std::cout << *it << std::endl;
	}\end{lstlisting}
	\vspace{-1.5em}
\end{figure}

\noindent Auf wichtige Feinheiten der C++-Variante wollen wir später nach der Erklärung der angewandten Konzepte eingehen.

Die C++-Iterator Objects sind relativ zu den Java-Iteratoren weniger objektorientiert.
Außerdem wurden im Beispiel \ref{code:iterator-cpp} einige Best-Practices angewandt, die ohne Wissen über die verwendeten Konzepte nicht offensichtlich sind.
Deshalb wollen wir folglich Iteratoren in C++ genauer betrachten.

\subsubsection{C++ Iteratoren}

Jeder Container-Typ der \texttt{std}-Bibliothek definiert einen eigenen Iterator als Typ-Alias, welcher das Interface einer C++ Iterator-Kategorie aus \autoref{table:cpp-iterator-types} implementiert.
Das implementierte Interface hängt jeweils von der Container-Struktur ab.

Algorithmen aus der \textit{Standard Template Library} (kurz STL) spezifizieren wiederum Iterator-Kategorien als Typparameter.
Iteratoren stellen demnach die Schnittstelle zwischen Algorithmen und Containern dar.

\begin{table}
	\vspace{-2em}
	\caption{C++ Iterator-Typ-Interface nach \cite[S.604 f.]{profcpp}}
	\label{table:cpp-iterator-types}
	\vspace{-1em}
	\caption*{\textbf{Legende}:\quad $^\ast\dotsc:=$ \texttt{operator}\dots,\qquad$\dots^\dag:=$ \dots-Konstruktor}

	\hspace{-1.5em}
	\begin{tabular}{l|c|c}
		\hline
		Interface-Kategorie                               & Operationsspezifikation                                                                                                                & Anmerkung                                    \\

		\hline
		\hline

		Input (\enquote{Read})                            & \{$^\ast$\texttt{++}, $^\ast$\texttt{*}, $^\ast$\texttt{->}, $^\ast$\texttt{=}, $^\ast$\texttt{==}, $^\ast$\texttt{!=}, Copy$^\dag$\}~ & Read-Only                                    \\

		Forward                                           & \{Default$^\dag$\} $\cup$ Input                                                                                                                                                       \\

		Bidirectional                                     & \{$^\ast$\texttt{--}\} $\cup$ Forward                                                                                                                                                 \\

		\shortstack{Random Access~~\vspace{1.1em}}        &
		~\shortstack{ \{$^\ast$\texttt{+}, $^\ast$\texttt{-}, $^\ast$\texttt{+=}, $^\ast$\texttt{-=} $^\ast$\texttt{<}, $^\ast$\texttt{>},                                                                                                        \\ $^\ast$\texttt{<=}, $^\ast$\texttt{>=}, $^\ast$\texttt{[]}\}~$\cup$ Bidirectional}
		                                                  & \shortstack{Equivalent zu Raw Pointer\vspace{1.1em}}                                                                                                                                  \\

		\shortstack{Contiguous\vspace{1.1em}}             & \shortstack{Random Access\vspace{1.1em}}                                                                                               & \shortstack{~Elemente adjazent $\Rightarrow$ \\ Speicherrepräsentationen adjazent} \\

		\hline

		\shortstack{Output (\enquote{Write})\vspace{1em}} & \shortstack{\{$^\ast$\texttt{++}, $^\ast$\texttt{*}, $^\ast$\texttt{=}, Copy$^\dag$\}\vspace{1em}}                                     & \shortstack{~Write-Only:                     \\ Ermöglicht \texttt{*iter = $\langle{value}\rangle$;}}  \\
	\end{tabular}
	\vspace{-1em}
\end{table}

\noindent Iterator-Typen, die in die ersten fünf Iterator-Kategorien aus \autoref{table:cpp-iterator-types} fallen und die Eigenschaften des \textit{Output}-Iterators nicht erfüllen, werden auch als \textit{konstant} bezeichnet und im Quellcode mit einem \texttt{const\_}-Prefix versehen.
Iteratoren, die zusätzlich die Eigenschaften des Output-Iterators erfüllen, werden auch \enquote{mutable} genannt.
Sie erhalten hingegen keine Kennzeichnung im Code.

Aus diesen Eigenschaften lässt eine informelle Vererbungshierarchie herleiten, die in \autoref{fig:iterator-hierarchie} dargestellt ist.

\begin{figure}
	\vspace{-1em}
	\caption{Informelle Vererbungshierarchie der C++ Iterator-Interfaces/Kategorien}
	\label{fig:iterator-hierarchie}

	\begin{tikzpicture}[semithick, node distance=2cm]
		\tikzstyle{textt}=[font={\scriptsize}]
		\tikzstyle{edge-text}=[-Latex, dotted, style={textt}, above, sloped, midway]
		\tikzstyle{state}=[draw, inner xsep=5pt, inner ysep=5pt, rounded corners=2pt, style={textt}, align=center]

		\node[style=state] (in) {{\tiny Constant}\\Input \texttt{It}};

		\node[style=state] (for) [right of=in] {{\tiny Constant}\\Forward \texttt{It}};
		\path[style=edge-text] (for.west) edge (in.east);

		\tikzset{node distance=2.5cm}

		\node[style=state] (bi) [right of=for] {{\tiny Constant}\\Bidirectional \texttt{It}};
		\path[style=edge-text] (bi.west) edge (for.east);

		\tikzset{node distance=2.9cm}

		\node[style=state] (rand) [right of=bi] {{\tiny Constant}\\Random Access \texttt{It}};
		\path[style=edge-text] (rand.west) edge (bi.east);

		\node[style=state] (cont) [right of=rand] {{\tiny Constant}\\Contiguous \texttt{It}};
		\path[style=edge-text] (cont.west) edge (rand.east);

		\tikzset{node distance=1.25cm}

		\node[style=state] (m_in) [below of=in] {{\tiny(Mutable)}\\Input \texttt{It}};
		\node[style=state] (m_for) [below of=for] {{\tiny(Mutable)}\\Forward \texttt{It}};
		\node[style=state] (m_bi) [below of=bi] {{\tiny(Mutable)}\\Bidirectional \texttt{It}};
		\node[style=state] (m_rand) [below of=rand] {{\tiny(Mutable)}\\Random Access \texttt{It}};
		\node[style=state] (m_cont) [below of=cont] {{\tiny(Mutable)}\\Contiguous \texttt{It}};

		\path[style=edge-text] (m_in.north) edge (in.south);
		\path[style=edge-text] (m_for.north) edge (for.south);
		\path[style=edge-text] (m_bi.north) edge (bi.south);
		\path[style=edge-text] (m_rand.north) edge (rand.south);
		\path[style=edge-text] (m_cont.north) edge (cont.south);

		\node[style=state] (out) [below of=m_bi] {Output \texttt{It}};

		\path[style=edge-text] (m_in.south) edge (out);
		\path[style=edge-text] (m_for.south) edge (out);
		\path[style=edge-text] (m_bi.south) edge (out);
		\path[style=edge-text] (m_rand.south) edge (out);
		\path[style=edge-text] (m_cont.south) edge (out);
	\end{tikzpicture}
	\vspace{-2em}
\end{figure}

\paragraph{Iteratoren auf Containern}
Genauer definieren \texttt{std}-Container zumindest die Mitglieder \texttt{$\langle{container}\rangle$::$($const\_$)$iterator}.
Wenn ein Container in der Hierarchie mindestens das Bidirectional-Interface implementiert, verfügt er zusätzlich über die \texttt{$($const\_$)$reverse\_iterator} Typ-Aliasse.

Instanzen der genannten Typ-Alias erlangt man durch das Aufrufen der \texttt{begin}, \texttt{cbegin}, \texttt{end} und \texttt{cend} Funktionen.
Für sie existieren Überladungen für die reversen Iteratoren, deren Namen jeweils mit einem \texttt{r}-Suffix versehen sind.
Hier ist es \textit{Best Practice}, sich die \textit{Argument Dependent Lookups} (kurz ADL) zunutze zu machen \cite[S.608]{profcpp}.

\paragraph{Argument Dependent Lookups}
ADL bezeichnet die Eigenschaft des Compilers, bei der Auflösung einer Funktion $F$ mit einem Parameter $T$ zuerst im Namensraum von $T$ nach einer passenden Überladung für $F$ zu suchen.
Falls dies fehlschlägt, sucht der Compiler in anderen Namensräumen wie \texttt{std} nach passenden Überladungen von $F$.
Wenn man jedoch expliziten den Bereichsauflösungsoperator mit Namensraum \texttt{std} verwendet, schließt man die Suche im Namensraum von $T$ aus.
Bei der Verwendung von Member-Methoden (z.B. \texttt{->begin}) wird hingegen die Suche in anderen Namensräumen ausgeschlossen.

%Somit werden bei eigen definierten Container-Typen, die mit \texttt{begin} funktionieren sollen, einfach für \texttt{begin} kein Namespace angegeben, um immer die passende Auflösung für \texttt{begin}-Funktion zu erhalten.

Nun haben sich alle Unbekannten aus Beispiel \ref{code:iterator-cpp} (sowie \ref{code:subscript-operator}) aufgelöst.
Trotzdem wollen wir darauf hinweisen, dass im C++-Code absichtlich \texttt{operator!=} zum Vergleich mit \texttt{cend(::it)} verwendet wurde.
Dies folgt aus \autoref{table:cpp-iterator-types}, da jeder Iterator-Typ den \texttt{operator!=} implementiert und sich dieser daher konsistent anwenden lässt.

\paragraph{Sortieren mit Iteratoren}

Die Semantik der Iterator-Hierarchie lässt sich nicht nur beim Iterieren, sondern auch bei der Anwendung von Algorithmen beobachten.
Wenn man bspw. die STL-Funktion \texttt{std::sort} verwenden möchte, muss man sicherstellen, dass die verwendete Datenstruktur mindestens einen (mutable) \texttt{RandomIt} implementiert.
Verwendet man den Algorithmus wie in \autoref{code:sorting-legacy} auf einer \texttt{std::list} mit bidirektionalen Iterator, verletzt man die Iterator-Typ-Hierarchie und erhält eine Fehlermeldung zur Übersetzungszeit.

\begin{figure}
	\vspace{-.5em}
	\caption{Sortieren mit zu schwachen C++ Iterator-Typ}
	\label{code:sorting-legacy}
	\begin{lstlisting}[language=C++]
auto test_sort_list(std::list<u_int32_t>& list) {
	std::sort(begin(list), end(list));
}\end{lstlisting}
	\vspace{-1em}
\end{figure}

% \paragraph{For-Each}
%
% Häufig kommt es vor, dass man sequenziell über einen Container iterieren möchte ohne auf die eigentlichen Iterator-Objekte zuzugreifen.
% Dafür ist eine Schleife mit expliziten Iteratoren wie in \ref{code:iterator-cpp} unnötig redundant und es bietet sich an die seit C++11 verfügbaren \textit{For-Each}-Schleife zu verwenden \ref{code:for-each-cpp}.
% Diese erstellen die Iteratoren implizit.
%
% \begin{figure}[H]
% \caption{For-Each Schleife in C++}
% \label{code:for-each-cpp}
% \begin{lstlisting}[language=C++]
% for ( const auto& fib_num : ::fib ) {
% std::cout << fib_num << std::endl;
% }\end{lstlisting}
% \end{figure}

%\noindent Die Autoren können bestätigen, dass \ref{code:for-each-cpp} in Clang mit \texttt{-O2} sehr ähnlichen Assembly-Code wie \ref{code:iterator-cpp} erzeugt \cite{compexp1:explicit}\cite{compexp1:implicit}.
%\cite{godbolt-iterator-implicit,godbolt-iterator-explicit}.

\noindent Wie im letzten Beispiel zu sehen ist, benötigen STL-Algorithmen zwei Iteratoren-Paare pro Container.
Allerdings kann das zu Mismatches zwischen den verwendeten Iteratorpaaren führen \cite{profcpp}, was nach der Einführung von C++20 Ranges leicht zu vermeiden ist.

\subsection{C++ Ranges}

Die Ranges Bibliothek wurden als einer der \enquote{Big Four} Neuerungen im C++20-Standard aufgeführt \cite{open-std.org}.
Sie stand seit 2018 zur Diskussion \cite{the-one-ranges-proposal} und wurde von Eric Niebler, dem Entwickler hinter der \texttt{ranges-v3} Bibliothek, mitentworfen \cite{ranges-v3}.

Bei einer C++20 Range handelt es sich um eine Abstraktion über iterierbare Sequenzen von Elementen, die dementsprechend alle STL-Container erfüllen.
Für diese Abstraktionen existieren auch Überladungen der STL-Algorithmen wie \texttt{sort}, durch die sich Beispiel \ref{code:sorting-legacy} bspw. weiter zu \autoref{code:sorting-ranges} verkürzen lässt.

\begin{figure}[H]
	\vspace{-.5em}
	\caption{Sortieren mit Ranges}
	\label{code:sorting-ranges}

	\begin{lstlisting}[language=C++]
	std::ranges::sort(::fib_messy);\end{lstlisting}
	\vspace{-1em}
\end{figure}

\noindent Vergleicht man allerdings den \texttt{-O2} Assembly-Code von GCC 13 und Clang 17 für den Code aus \autoref{code:sorting-legacy} und \ref{code:sorting-ranges}, dann fällt auf, dass GCC zur Ranges-Variante deutlich längeren Assembly-Code generiert (vgl. \cite{compexp2:clang-leg} mit \cite{compexp2:clang-ranges}, \cite{compexp2:gcc-leg} mit \cite{compexp2:gcc-ranges}).
Trotz dessen, dass mehr Instruktionen nicht unbedingt eine längere Laufzeit implizieren, finden die Autoren dies bemerkenswert.

Zu dem verkürzten STL-Algorithmen bieten Ranges durch \textit{Views} und \textit{Range Adapters} ähnlich zur Java Streams-Bibliothek die lazy-Anwendung von aufeinanderfolgenden Transitionen.
Im Folgenden wollen wir uns allerdings vorerst näher mit den Details der Ranges-Library beschäftigen, um dann auf Views und Laziness zurückzukommen.

\subsubsection{Komposition}

Die Ranges-Bibliothek besteht aus den folgenden vier Komponenten \cite{profcpp}:

\begin{enumerate}[1.]
	\item \textbf{Ranges}: Ein \textit{Concept} (= formale Spezifikation für Eigenschaften im Quellcode \cite[vgl. S.454 ff.]{profcpp}), welches die Anforderung für eine Iteration über eine Sequenz spezifiziert.
	      Diese Anforderungen sind:

	      \begin{itemize}
		      \item Einein \texttt{begin}- und \texttt{end}-Iterator
		      \item Einen \texttt{begin}-Iterator und $n\geqslant0$
		      \item Einen \texttt{begin}-Iterator und ein Prädikat
		      \item Unendliche Ranges/ Unbeschränktheit (Spezialfall)
	      \end{itemize}

	\item \textbf{Algorithms}: Überladungen der STL-Algorithmen aus dem \texttt{<algorithm>}-Header, die Ranges als Argumente akzeptieren

	\item \textbf{Views}: Nicht-mutierende Transformationen auf Ranges, die durch \textit{Range Adapters} erstellt werden und sich durch \texttt{|} zu Pipelines verbinden lassen

	\item \textbf{Factories}: Spezielle Konstruktoren für Ranges, bspw. \texttt{iota}
\end{enumerate}

\noindent Da durch Ranges fundamentale Zugriffseigenschaften von Containern erhalten bleiben müssen, existieren äquivalente Range-Concepts zu den C++ Iterator-Typen aus \autoref{table:cpp-iterator-types}.
Diese sind nach dem Schema $\langle$\textit{it\_type}$\rangle$\texttt{\_range} benannt.
Ähnlich zu Containern lassen sich auch auf Ranges die \texttt{begin}, \texttt{cbegin}, \texttt{end} und \texttt{cend} Funktionen mittels ADL aufrufen.

Allerdings existieren für Ranges spezielle Hilfsfunktionen, die im \texttt{<ranges>}-Header definiert sind und keinen Gebrauch von ADL machen.

Sei $R$ eine beliebige Range.
Dann existieren für $R$ die Funktionen \texttt{ranges::empty} mit $R\to\{\texttt{true},\texttt{false}\}$, \texttt{ranges::$($s$)$size} mit (soweit technisch möglich) $R\to\mathbb{Z}$ oder $\mathbb{N}_0$ und \texttt{ranges::$($c$)$data}, welche einen Pointer auf den Begin der Range zurückgibt.

Die \texttt{ranges::$($s$)$size}-Funktionen funktionieren nur auf Ranges, deren Länge sich in einer Laufzeitkomplexität von $\mathcal{O}(1)$ bestimmen lassen.
Eine Alternative mit Laufzeitkomplexität in $\mathcal{O}(n)$ ist die Funktion \texttt{ranges::distance}.

Nun mehr zu den konkreten Anwendungsmöglichkeiten von Ranges.

\subsubsection{Projektionen}

Die für Ranges überladenen STL-Algorithmen bieten neben den bekannten Überladungen für normale Container eine Zusätzliche an.
Diese erwartet eine Projektionsfunktion als Parameter, welche vor der Anwendung des Algorithmus out-of-place auf die Elemente der Range angewandt wird.

Dies ist nützlich, wenn eine Range eines Typs anhand eines Mitglieds sortiert werden soll, wie es bspw. häufig bei \texttt{struct}s der Fall ist.
Zum Beispiel könnte eine Range aus \texttt{struct Student}s durch eine Projektion in Form eines Lambdas oder einer Funktionsreferenz sehr kompakt nach Nachnamen, angehöriger Fakultät oder Notendurchschnitt sortiert werden.

Durch die für Range-Algorithmen typischen Projektionsparameter benötigt man also nicht immer \enquote{schwerere Geschütze} wie Range Adapters und Views.

\subsubsection{Views}

Views stellen eine Schicht zwischen zwei Ranges dar, wobei die Darüberliegende durch eine out-of-place Anwendung einer Funktion (genauer eines \textit{Range Adapters}) auf einer Darunterliegenden resultiert.
Views sind dabei wiederum Ranges, Ranges aber nicht immer Views.
In der Sprache der Mengenlehre ausgedrückt gilt also: Views $\subsetneq$ Ranges.
Konkret sind Views in C++ durch leichtgewichtige Objekte realisiert.

Views ergreifen kein Besitz von den Elementen der zugrundeliegenden Range und können diese somit auch nicht verändern.

\subsubsection{Range Adapters}

Die Range-Adapter-Funktionen sind im Header \texttt{<ranges>} definiert.
Sie bieten einen Konstruktor an, der neben den Adapter-spezifischen Parametern zur Transformationssemantik eine Range als Eingabe fordert.
Nützliche Adapters sind bspw. \texttt{filter}, \texttt{transform}, \texttt{take\_while} oder \texttt{zip}.
Da man Range Adapters allerdings auch durch den Binary-OR-Operator \texttt{operator|} zu einer Pipeline verbinden kann, um sie anzuwenden, kann es ggf. Sinn machen, auf Konstruktoren zu verzichten.
Das trifft zu, wenn man eine View-Pipeline aus mehreren Range Adapters aufbauen möchte (siehe \autoref{code:view-pipeline-creation}).

\begin{figure}[H]
	\vspace{-1em}
	\caption{Erstellung eines View-Pipeline aus einer Ranges}
	\label{code:view-pipeline-creation}

	\begin{lstlisting}[language=C++]
	// Construction of View-pipeline through Range Adapter constructor
	std::views::filter(fib, &is_odd)
		| // one or more following range adapters ...
	// Construction of View-pipeline through operator| chaining
	fib | std::views::filter(&is_odd)
		| // "-" ...
	\end{lstlisting}
	\vspace{-1.5em}
\end{figure}

\noindent Die Range Adapters sind im Namensraum \texttt{std::ranges::views} und \texttt{std::views} unter \texttt{$\langle adapter\_name\rangle$} oder in \texttt{std::ranges} unter dem Namen \texttt{$\langle adapter\_name\rangle$\_view} verfügbar.
Prinzipiell ähneln einzelne Range Adapters Fragmenten des Schleifen-Rumpfes von First-Class Iterators (vgl. \ref{enum:iterator-types}).

\subsubsection{Laziness}

Laziness im Kontext von C++20 Views bedeutet, dass Range Adapters erst auf die zugrundeliegende Range angewandt werden, wenn über eine resultierende View iteriert wird, um ihre Elemente zu dereferenzieren.
Das Erstellen und Speichern von Views in Variablen verursacht kaum kosten.
Das hat zur Folge, dass die Anwendung von STL-Algorithmen auf Views zur eager-Auswertung der View-Pipeline führt.

Das Konzept der Laziness findet sich ferner in der Java-Streams-Bibliothek, Kotlin Sequences oder in funktionalen Programmiersprachen wie Haskell wieder.
Laziness hat das Potential, effizient zu sein.
Beispielsweise zeigt \autoref{fig:ranges-laziness-example} eine Visualisierung der Auswertung einer beispielhaften View-Pipeline auf dem Array \texttt{fib}.
Die einzelnen Range-Adapaters werden sukzessiv und out-of-place auf die Elemente von \texttt{fib} angewendet und sparen durch den Einsatz der \texttt{take}-Funktion und Laziness Anwendungen der Filter-Funktion auf die letzten drei Elemente des Arrays.

\begin{figure}
	\vspace{-1em}
	\caption{Visualisierung der lazy Auswertung von Range Adapters auf der \texttt{fib}-Range\\\textit{Auswertungsreihenfolge}: Von oben $\to$ unten, dann von links $\to$ rechts}
	\label{fig:ranges-laziness-example}
	\hspace{-2em}
	\begin{tikzpicture}[scale=.65, node distance=6pt,every node/.style={inner ysep=12pt, inner xsep=14pt, font=\scriptsize}]
		\draw[help lines,step=1, semithick] (0,0) grid (11,-1);

		\node (exp1) at (-2,-.5) {Ausgangssequenz:};
		\node at (-2, .2) {\texttt{Indizes}:};

		\foreach \val [count=\i] in {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55} {
				\node[align=center] (A\i) at (\i-.5,-.5) {\val};
			}

		\foreach \i in {1,...,11} {
				\node[above of=A\i, yshift=0.3cm] {\texttt\i};
			}

		\draw[help lines,step=1, semithick] (0,-2) grid (11,-3);
		\foreach \val [count=\i] in {, 1, 1, , 3, 5, , 13, , , } {
				\node[align=center] (B\i) at (\i-.5,-2.5) {\val};
			}

		\node (exp2) at (-2,-1.5) {\shortstack{Filterung:\\$n\equiv1\mod 2$}};
		\foreach \i in {2,3,5,6,8} {
				\path (A\i) edge[-Latex, draw, semithick] (B\i);
			}
		\foreach \i in {1,4,7} {
		\draw[semithick, -{Rays[]}] (A\i) -- (B\i);
		}

		\draw[help lines,step=1, semithick] (0,-4) grid (11,-5);
		\foreach \val [count=\i] in {, , 1, , 3, 5, , , , , } {
				\node[align=center] (C\i) at (\i-.5,-4.5) {\val};
			}

		\node (exp3) at (-2,-3.5) {\texttt{drop(1) | take(3)}};
		\foreach \i in {3,5,6} {
				\path (B\i) edge[-Latex, draw, semithick] (C\i);
			}
		\foreach \i in {2,8} {
		\draw[semithick, -{Rays[]}] (B\i) -- (C\i);
		}

		\draw[help lines,step=1, semithick] (0,-6) grid (11,-7);
		\foreach \val [count=\i] in {, , 3, , 7, 11, , , , , } {
				\node[align=center] (D\i) at (\i-.5,-6.5) {\val};
			}

		\node (exp4) at (-2,-5.5) {\shortstack{Transformation:\\$x\mapsto 2x+1$}};
		\foreach \i in {3,5,6} {
				\path (C\i) edge[-Latex, draw, semithick] (D\i);
			}

		\draw (C7.south west) edge [draw,decorate, decoration={brace, mirror}] node[below=-6pt] {\texttt{take(3)} erfüllt?} (C7.south west -| C8.south east);

		\tikzset{node distance=0pt,every node/.style={inner ysep=5pt, inner xsep=5pt, font=\scriptsize}}
		\draw (B11.north east) edge [draw,decorate, decoration={brace}] node[right, align=left, text width=2.5cm] {
				out-of-place\\
				~\\
				Werden dynamisch erstellt, weshalb eigentlich keine leeren Indizes zwischen Werten existieren
			} (B11.north east |- D11.south east);
	\end{tikzpicture}
	\vspace{-2em}
\end{figure}

\noindent Laziness ermöglicht außerdem die Arbeit auf unendlichen Ranges, auf die im Laufe des folgenden Abschnitts eingegangen werden sollen.

\subsubsection{Range Factories}

Ranges lassen sich auch mithilfe von \textit{Range Factories} erstellen.
Der C++20-Standard definiert vier Typen: \texttt{views::empty}, \texttt{views::single}, \texttt{views::iota} und \texttt{views::istream} (bzw. \texttt{basic\_istream\_view}).
Die letzten beiden Rage Factories erzeugen unbeschränkte Ranges.

Im C++23-Standard wurden die zusätzlichen Factories \texttt{views::repeat} und \texttt{std::generator} ergänzt, von denen sich letzterer auch als Range nutzen lässt.
Generatoren werden in Programmiersprachen wie Python und ab ECMAScript 2015 verwendet, um die Funktionalität von True Iterators zu realisieren (vgl. \ref{enum:iterator-types}).

Abgesehen von \texttt{std::generator} ähneln Range Adapter und Factories den True Iterators, wenn man sie in For-Each Schleifen verwendet.
Beispielsweise kann man eine vorhandene Range kompakt mit ihren Indizes versehen, indem man den C++23 Adapter \texttt{views::enumerate} verwendet (siehe \autoref{code:true-iterator-range}).
Bei solchen und ähnlichen Verwendungen von Range Adaptern empfinden die Autoren es als angemessen, Range Adapters mit Konstruktoren einzusetzen.

\begin{figure}
	\vspace{-.5em}
	\caption{True Iterator Semantik mit C++23 Range Adapter Konstruktor}
	\label{code:true-iterator-range}

	\begin{lstlisting}[language=C++]
	for(const auto &[i, f] : std::views::enumerate(::fib)) {
		std::cout << i << ':' << f << std::endl;
	}
	\end{lstlisting}

	\vspace{-1em}
\end{figure}

Nach der ausführlichen Diskussion aller Iterator-Kategorien, Ranges und Views, soll sich der nächste Teil dieser Ausarbeitung ihrer Bewertung widmen.

\section{Ergebnisse}

Im Folgenden soll ein Codebeispiel zum Einsatz kommen, um Ranges nach den Kriterien der \textit{Abstraktion}, \textit{Lesbarkeit} und \textit{Performanz} mit Iteratoren zu vergleichen.
Die \enquote{Lesbarkeit} ist hier aufgrund von variierenden Vorlieben und Erfahrungen subjektiv und auch mit dem Abstraktionsniveau verbunden.

\paragraph{Codebeispiel}
Das Beispiel soll eine vereinfachte Funktion eines japanischen Vokabel-Trainers sein.
Diese soll ein \texttt{std::vector} aus 3440 Vokabel-\texttt{struct}s für das Abfragen des Nutzers transformieren, wobei die Ausführungslaufzeit der Transformationen jeweils für eine Realisierung in Ranges und Iteratoren gemessen wurde.
Weitere Details sind aus \autoref{code:benchmark-ranges} zu entnehmen.

\begin{figure}
	\vspace{-1em}
	\caption{Benchmarking-Ausschnitte des Testprogramms, \texttt{urlPageParameter} wird zufällig gewählt}
	\label{code:benchmark-ranges}
	\begin{minipage}{0.475\textwidth}
		\begin{lstlisting}[basicstyle={\ttfamily\tiny}]
std::array<std::string,20> filtered {};
auto dropCount = urlPageParameter * 20;
auto takeCount = 20;

for (const auto& vocab : vocabList) {
    if (!vocab.isCommon) {
        continue;
    }
    if (0 <= --dropCount) {
        continue;
    }
    if (0 <= --takeCount) {
        filtered[takeCount] = vocab.reading;
        continue;
    }
    break;
}

for (const auto& v : filtered) {
    std::cout << v << ' ';
} \end{lstlisting}
		\caption*{$i$) Iteratoren}
	\end{minipage}
	\begin{minipage}{0.475\textwidth}
		\begin{lstlisting}[basicstyle={\ttfamily\tiny}]
auto filteredList {
    vocabList | std::views::filter([](const auto& v){
			return v.isCommon;
		})
        | std::views::transform([](const auto& v){
			return v.reading;
		})
        | std::views::drop(20*urlPageParameter)
        | std::views::take(20)
};

for (const auto& v : filteredList) {
    std::cout << v << ' ';
}
\end{lstlisting}
		\caption*{$ii$) Ranges}
		%\vspace{2em}
	\end{minipage}
	\vspace{-2em}
\end{figure}

\paragraph{Lesbarkeit}
Das Ranges-Beispiel in \ref{code:benchmark-ranges} $ii)$ zeigt, dass die Programmlogik vertikal deutlich kompakter und strukturierter als der Code mit Iteratoren ist.
Der funktionale Stil und die Idempotenz der Operationen in der View-Pipeline machen den Code zudem gut verständlich.
Auf der anderen Seite lässt sich der Iterator-Code verstehen, wenn man nicht mit dem funktionalen Syntax von View-Pipelines vertraut ist.

\paragraph{Abstraktion}
Das Beispiel mit Iteratoren ist durch explizite Initialisierungen und Modifizierung von Zählvariablen technischer als der abstrakte Ranges-Code.
So ist es bspw. möglich für die Selektion ein \texttt{std::array} als Containertyp zu wählen, was bei Ranges aufgrund der Abstraktion nicht zur Wahl steht.

\paragraph{Performanz}

Das Ranges-Beispiels ist dynamischer Natur, was in der Theorie Auswirkung auf die Laufzeit haben sollte.
Bei grober Betrachtung der Messungen in \autoref{fig:plot} fällt hingegen auf, dass die Zugriffsdauer auf die Vokabel-Liste für Iteratoren und Ranges ungefähr gleichschnell anwächst.
Eindeutige Unterschiede existieren hingegen zwischen GCC und Clang.
Der letztere Compiler produziert für unsere Beispiele den schnelleren Code.

Genauer betrachtet ist hervorzuheben, dass Clang für die Ranges-Realisierung schnelleren Code produziert als für den ähnlichen Iterator-Code.
Diese Auffälligkeit konnte in einem zweiten Test auf einem anderen Gerät bestätigt werden.
Die Autoren vermuten, dass Laziness dem Compiler Optimierungen ermöglicht, die zu weniger Branch-Misses führen könnten.
Allerdings ist nicht klar, ob sich diese Beobachtung auch für größere Datenmengen hält.

\begin{figure}
	\vspace{-1em}
	\caption{Ausführungsdauer der Zugriffe auf Teilsequenzen der Vokabelliste aus \ref{code:benchmark-ranges}}
	\label{fig:plot}
	\begin{tikzpicture}
		\begin{axis}[
				width=\textwidth, height=7.5cm,
				xlabel={Indizes von 20er-Folgen aus einem \texttt{std::vector<JapVocab>} \texttt{struct}s},
				ylabel={$t$ in \textit{ns}},
				%
				xmin=0, xmax=149,
				ymin=500, ymax=3250,
				%
				legend style={at={(0.025,0.95)},anchor=north west},
				cycle list name=color list,
				%
				grid=both, % minor and major
				major grid style={line width=.1pt,draw=gray},
				minor grid style={dotted,gray},
				minor y tick num=1,
				minor x tick num=0,
				ytick={500,1000,...,3000},
				%mark repeat=2
			]

			\addplot [red, densely dotted] table [x=i, y=s, col sep=space] {../measurements/clang-iter-2.csv};
			\addlegendentry{\scriptsize Clang Iter (2)}

			\addplot [dotted, blue] table [x=i, y=s, col sep=space] {../measurements/clang-ranges-2.csv};
			\addlegendentry{\scriptsize Clang Ranges (2)}

			\addplot [yellow] table [x=i, y=s, col sep=space] {../measurements/gcc-iter.csv};
			\addlegendentry{\scriptsize GCC Iter}

			\addplot [green] table [x=i, y=s, col sep=space] {../measurements/gcc-ranges.csv};
			\addlegendentry{\scriptsize GCC Ranges}

			\addplot [red] table [x=i, y=s, col sep=space] {../measurements/clang-iter.csv};
			\addlegendentry{\scriptsize Clang Iter}

			\addplot [blue] table [x=i, y=s, col sep=space] {../measurements/clang-ranges.csv};
			\addlegendentry{\scriptsize Clang Ranges}

		\end{axis}
	\end{tikzpicture}

	\vspace{-2em}
\end{figure}

\section{Fazit}

Aus der ausführlichen Diskussion der C++-Speicherzugriffsarten geht hervor, dass moderne C++-Standards dem Programmierenden viel Freiraum im Umgang mit Containern bieten.
Dabei sind C++23 Ranges eine interessante Ergänzung, die neue Variationen ermöglichen oder bestehende erweitern.
Sie bieten ein hohes Abstraktionsniveau und sind gut lesbar, wenn man mit ihrem Syntax vertraut ist.
Außerdem sind sie für unser Beispiel auf einer kleine Datenmenge und Clang als Compiler performanter als Iteratoren, weswegen sie sich aufgrund ihrer weiteren Vorteile ein vermehrter Einsatz in der Praxis lohnen könnten.

Allerdings würden die Autoren davon abraten, nun schon bestehenden Code, der auf Iteratoren setzt, mit View-Pipelines zu ersetzen.
Benchmarking schadet hier nicht.


\section*{Reproduzierbarkeit}

Um die Reproduzierbarkeit der im Artikel bereitgestellten Daten sicherzustellen, haben die Autoren für dieses Projekt ein \href{https://github.com/becknik/SeminarModernCpp}{GitHub Aufbewahrungsort} eröffnet.
In diesem ist der vollständige Code der Benchmarks aus \autoref{code:benchmark-ranges}, die Versionsnummern der verwendeten Compiler und Tools, sowie die Messdaten aus \autoref{fig:plot} bereitgestellt.
Außerdem ist der Quellcode dieses Artikels dort veröffentlicht.

Elemente, die aufgrund von Längenbeschränkung nicht in den Artikel aufgenommen werden konnten, sind auch in dem Aufbewahrungsort veröffentlicht.
Dazu gehören eine API-Zusammenfassung von Range Adapters im mathematischen Stil von \autoref{table:cpp-iterator-types}, der Code zur Visualisierung von Laziness aus \autoref{fig:ranges-laziness-example} und einem kleinen Experiment mit dem momentan noch nicht in Compilern implementierten \texttt{std::generator}.

\newpage
\printbibliography
\end{document}
